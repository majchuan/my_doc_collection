1. what is postgresql ? 
    -> A open source db
    -> High extensibility like custom types, functions, and POstGIS
    -> Complex query like CTEs, window functions
    -> MVCC-based concurrency.
    -> Strict enformcement Data Integrity. 
2. ACID compliance and MVCC
    -> Atomicity: all operation in a trnsaction succeed or fail together.
    -> Consistency: Database remains valid after transactions.
    -> Isolation: Transactions don't interfere with each other.
    -> Durability: COmmitted data survives crashes.

    MVCC(Multi-Version Concurrency Control)
        -> Allows concurrrent read/write without locking
        -> Each transaction sees a snapshot of the database
        -> Prevents read-write conflict and imporves performace under load.
3. Common Data Types.
INTEGER -> Whole NUmber. 
VARCHAR -> Variable-length strings
TEXT    -> Unlimited-length strings
BOOLEAN -> True/false
DATE    -> Calendar date
JSONB   -> Binary JSON(Indexed, efficient)
ARRAY   -> Array of any type
UUID    -> Universally unique identifier 

UUID in Distributed Systems.
    -> Decentralized Generation: Each node or service can geneRATE UUIDs independently
    -> Low collision Proability : UUIDs are 128 bit values. 
    -> No coordination Needed: don't require a central authority or sequence.

------------------------------------------------------------------------------------------------------
Table Creation:
CREATE TABLE users{
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(10),
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
}
Example
CREATE TABLE departments (
  department_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,// GENERATED BY DEFAULT AS IDENTITY
  department_name VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE employees (
  employee_id SERIAL PRIMARY KEY,
  employee_name VARCHAR(100) NOT NULL,
  email TEXT UNIQUE,
  age INT CHECK (age >= 18),
  department_id INT NOT NULL,
  FOREIGN KEY (department_id) REFERENCES departments(department_id) 
    ON DELETE CASCADE 
    ON UPDATE CASCADE
);

GENERATED ALWAYS AS IDENTITY: 
PostgreSQL always generates the value; manual inserts are blocked unless overridden.

GENERATED BY DEFAULT AS IDENTITY: 
PostgreSQL generates the value unless one is provided manually.
-------------------------------------------------------------------------------------------------------
Create Index:
CREATE INDEX idx_users_email ON users (email); -> Create an index on the email column of the user table.

Create Composite Index:
CREATE INDEX idx_users_name ON users (last_name, first_name);

Create Partial Index:
CREATE INDEX idx_active_users ON users (email) WHERE is_active = true;
------------------------------------------------------------------------------------------------------

SQL Query
1.  CRUD Operations.
SELECT 
INSERT INTO
UPDATE xxx SET
DELETE FROM 

2.  JOINS
INNER JOIN  -> Return rows with matching values in both tables
LEFT JOIN   -> Return rows from the left table , and match rows from right table
RIGHT JOIN  -> Return rows from the right table, and match rows from left table
FULL JOIN   -> Return all rows combine the result of both a left join and right join
CROSS JOIN  -> No ON clause or join condition specified with a CROSS JOIN, A CROSS JOIN will result m*n rows

3.  CTEs
Common Table Expressions
Defined using WITH, they improve readbility and resuability.

WITH high_value_orders AS (
  SELECT user_id FROM orders WHERE total > 100
)
SELECT name FROM users WHERE id IN (SELECT user_id FROM high_value_orders);

4.  Window Functions
ROW_NUMBER() -> Assign a unique row number per partition
RANK()       -> Assign rank with gaps for ties
LEAD()       -> Accesses the next row's value
LAG()        -> Accesses the previouse row's value

5.  Aggregation
COUNT()
SUM()
AVG()
MIN()
MAX()
----------------------------------------------------------------------------------------------------------------

STORE PROCEDURES AND FUNCTIONS
written in PL/PgSQL

Store Procedures:
CREATE PROCEDURE update_salary(emp_id INT, new_salary NUMERIC)
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE employees SET salary = new_salary WHERE employee_id = emp_id;
END;
$$;

PL/PgSQL Language
    -> support control structures: IF , LOOP, CASE, RAISE.
    -> allow variable declarations and error handling.
    -> Parameters IN, OUT, INOUT 
Example with OUT:
CREATE PROCEDURE get_user_email(IN user_id INT, OUT email TEXT)
LANGUAGE plpgsql AS $$
BEGIN
  SELECT users.email INTO email FROM users WHERE id = user_id;
END;
$$;

Transaction Control:
BEGIN
    CALL process_order(123)
COMMIT;

Error Handling
USE EXCEPTION to catch and respond errors:

BEGIN
  -- risky operation
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'Something went wrong';
END;

EXAMPLE:
CREATE OR REPLACE PROCEDURE transfer_funds(
  IN sender_id INT,
  IN receiver_id INT,
  IN amount NUMERIC
)
LANGUAGE plpgsql
AS $$
DECLARE
  sender_balance NUMERIC;
BEGIN
  -- Check sender's balance
  SELECT balance INTO sender_balance FROM accounts WHERE id = sender_id;

  IF sender_balance < amount THEN
    RAISE EXCEPTION 'Insufficient funds';
  END IF;

  -- Deduct from sender
  UPDATE accounts SET balance = balance - amount WHERE id = sender_id;

  -- Add to receiver
  UPDATE accounts SET balance = balance + amount WHERE id = receiver_id;

  -- Commit the transaction
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
$$;


Function:
CREATE FUNCTION get_user_email(user_id INT) RETURNS TEXT AS $$
BEGIN
  RETURN (SELECT email FROM users WHERE id = user_id);
END;
$$ LANGUAGE plpgsql;

Triggers and Event-Driven logic
Triggers automatically execute a function before or after INSERT, UPDATE, AND DELETE.
USEFUL for audit logging, data validation, or real-time update

CREATE FUNCTION update_timestamp() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_timestamp();


JSONB 
JSONB stores JSON in a binary format -- efficeient and indexable. 

SELECT data->>'title' FROM documents WHERE data @> '{"author": "Marc"}';


Table inheritance and Partitioning
Table inheritance rarely use in modern system.
Partitioning SPlits large tables into manageable chunks based on a key. 

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  order_date DATE,
  amount NUMERIC
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2025 PARTITION OF orders
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

BACKUP ,RESTORE AND REPLICATION
pg_dump: Used to xport a PostgreSQL database into a script or a file.
pg_restore: Restores from a non-plain format dump.
psql: Can import plain SQL dumps.

MONITORING AND MAINTENANCE
pg_stat_statement:Tracks query preformance and frequence.
pgAdmin: GUI for postgreSQL management

VACUUMING AND AUTOVACUUM
Vacuum: Cleans up dead tuples to reclaim space.
Autovacuum:Bacground process that triggers vacuum based on threholds.
Monitor with pg_stat_user_tables, and pg_stat_all_tables.

DEADLOCKS.
Use pg_stat_activity to inspect locks.

LONG-RUNNING QUERIES
Use pg_stat_activity to find queries running too long.
kill with pg_terminate_backend(pid) 
